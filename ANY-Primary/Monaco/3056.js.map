{"version":3,"file":"3056.js","mappings":"8IAAA,ylD","sources":["file:///E:\\Downloads\\monaco-editor-main\\website\\src\\website\\data\\home-samples\\sample.wgsl.txt"],"sourcesContent":["export default \"// A fragment shader which lights textured geometry with point lights.\\n// Taken from the introduction of the WebGPU Shading Lnaguage Specification\\n// https://w3.org/TR/WGSL\\n\\n// Lights from a storage buffer binding.\\nstruct PointLight {\\n  position : vec3f,\\n  color : vec3f,\\n}\\n\\nstruct LightStorage {\\n  pointCount : u32,\\n  point : array<PointLight>,\\n}\\n@group(0) @binding(0) var<storage> lights : LightStorage;\\n\\n// Texture and sampler.\\n@group(1) @binding(0) var baseColorSampler : sampler;\\n@group(1) @binding(1) var baseColorTexture : texture_2d<f32>;\\n\\n// Function arguments are values from from vertex shader.\\n@fragment\\nfn fragmentMain(@location(0) worldPos : vec3f,\\n                @location(1) normal : vec3f,\\n                @location(2) uv : vec2f) -> @location(0) vec4f {\\n  // Sample the base color of the surface from a texture.\\n  let baseColor = textureSample(baseColorTexture, baseColorSampler, uv);\\n\\n  let N = normalize(normal);\\n  var surfaceColor = vec3f(0);\\n\\n  // Loop over the scene point lights.\\n  for (var i = 0u; i < lights.pointCount; i++) {\\n    let worldToLight = lights.point[i].position - worldPos;\\n    let dist = length(worldToLight);\\n    let dir = normalize(worldToLight);\\n\\n    // Determine the contribution of this light to the surface color.\\n    let radiance = lights.point[i].color * (1 / pow(dist, 2));\\n    let nDotL = max(dot(N, dir), 0);\\n\\n    // Accumulate light contribution to the surface color.\\n    surfaceColor += baseColor.rgb * radiance * nDotL;\\n  }\\n\\n  // Return the accumulated surface color.\\n  return vec4(surfaceColor, baseColor.a);\\n}\\n\";"],"names":[],"sourceRoot":""}